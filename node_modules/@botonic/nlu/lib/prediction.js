(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "@tensorflow/tfjs", "./preprocessing", "./ner"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("@tensorflow/tfjs"), require("./preprocessing"), require("./ner"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.tfjs, global.preprocessing, global.ner);
    global.prediction = mod.exports;
  }
})(this, function (_exports, tf, _preprocessing, _ner) {
  "use strict";

  var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.getPrediction = getPrediction;
  _exports.getIntent = getIntent;
  Object.defineProperty(_exports, "getEntities", {
    enumerable: true,
    get: function get() {
      return _ner.getEntities;
    }
  });
  tf = _interopRequireWildcard(tf);

  function getPrediction(input, model, nluData) {
    var tokenizer = new _preprocessing.Tokenizer(nluData.vocabulary);
    var sequence = tokenizer.samplesToSequences(input)[0];
    var paddedSequence = (0, _preprocessing.padSequences)([sequence], nluData.maxSeqLength).dataSync();
    return model.predict(tf.tensor([paddedSequence])).dataSync();
  }

  function getIntent(prediction, intentsDict, language) {
    var intent = {};
    intent.intents = Array.from(prediction).map(function (confidence, i) {
      return {
        intent: intentsDict[i],
        confidence: confidence
      };
    }).sort(function (a, b) {
      return b.confidence - a.confidence;
    });
    intent.language = language;
    intent.intent = intent.intents[0].intent;
    intent.confidence = intent.intents[0].confidence;
    return intent;
  }
});