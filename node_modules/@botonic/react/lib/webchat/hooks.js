"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.webchatReducer = webchatReducer;
exports.useWebchat = useWebchat;
exports.useTyping = useTyping;
exports.usePrevious = usePrevious;
exports.useComponentVisible = useComponentVisible;
exports.webchatInitialState = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = require("react");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var webchatInitialState = {
  width: 300,
  height: 450,
  messagesJSON: [],
  messagesComponents: [],
  replies: [],
  latestInput: {},
  typing: false,
  webview: null,
  webviewParams: null,
  session: {},
  user: null,
  lastRoutePath: null,
  handoff: false,
  theme: {
    brandColor: '#0099ff',
    textPlaceholder: 'Ask me something...',
    title: 'Botonic'
  },
  error: {},
  devSettings: {},
  isWebchatOpen: false
};
exports.webchatInitialState = webchatInitialState;

function webchatReducer(state, action) {
  switch (action.type) {
    case 'addMessage':
      if (state.messagesJSON && state.messagesJSON.find(function (m) {
        return m.id === action.payload.id;
      })) return state;
      return _objectSpread({}, state, {
        messagesJSON: [].concat((0, _toConsumableArray2["default"])(state.messagesJSON || []), [_objectSpread({}, action.payload)])
      });

    case 'addMessageComponent':
      return _objectSpread({}, state, {
        messagesComponents: [].concat((0, _toConsumableArray2["default"])(state.messagesComponents), [action.payload])
      });

    case 'updateMessage':
      var msgIndex = state.messagesJSON.map(function (m) {
        return m.id;
      }).indexOf(action.payload.id);
      if (msgIndex > -1) return _objectSpread({}, state, {
        messagesJSON: [].concat((0, _toConsumableArray2["default"])(state.messagesJSON.slice(0, msgIndex)), [_objectSpread({}, action.payload)], (0, _toConsumableArray2["default"])(state.messagesJSON.slice(msgIndex + 1)))
      });
      return state;

    case 'updateReplies':
      return _objectSpread({}, state, {
        replies: action.payload
      });

    case 'updateLatestInput':
      return _objectSpread({}, state, {
        latestInput: action.payload
      });

    case 'updateTyping':
      return _objectSpread({}, state, {
        typing: action.payload
      });

    case 'updateWebview':
      return _objectSpread({}, state, {}, action.payload);

    case 'updateSession':
      return _objectSpread({}, state, {
        session: _objectSpread({}, action.payload)
      });

    case 'updateUser':
      return _objectSpread({}, state, {
        user: _objectSpread({}, action.payload)
      });

    case 'updateLastRoutePath':
      return _objectSpread({}, state, {
        lastRoutePath: action.payload
      });

    case 'updateHandoff':
      return _objectSpread({}, state, {
        handoff: action.payload
      });

    case 'updateTheme':
      return _objectSpread({}, state, {
        theme: _objectSpread({}, action.payload)
      });

    case 'updateDevSettings':
      return _objectSpread({}, state, {
        devSettings: _objectSpread({}, action.payload)
      });

    case 'toggleWebchat':
      return _objectSpread({}, state, {
        isWebchatOpen: action.payload
      });

    case 'setError':
      return _objectSpread({}, state, {
        error: action.payload || {}
      });

    default:
      throw new Error();
  }
}

function useWebchat() {
  var _useReducer = (0, _react.useReducer)(webchatReducer, webchatInitialState),
      _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
      webchatState = _useReducer2[0],
      webchatDispatch = _useReducer2[1];

  var addMessage = function addMessage(message) {
    return webchatDispatch({
      type: 'addMessage',
      payload: message
    });
  };

  var addMessageComponent = function addMessageComponent(message) {
    return webchatDispatch({
      type: 'addMessageComponent',
      payload: message
    });
  };

  var updateMessage = function updateMessage(message) {
    return webchatDispatch({
      type: 'updateMessage',
      payload: message
    });
  };

  var updateReplies = function updateReplies(replies) {
    return webchatDispatch({
      type: 'updateReplies',
      payload: replies
    });
  };

  var updateLatestInput = function updateLatestInput(input) {
    return webchatDispatch({
      type: 'updateLatestInput',
      payload: input
    });
  };

  var updateTyping = function updateTyping(typing) {
    return webchatDispatch({
      type: 'updateTyping',
      payload: typing
    });
  };

  var updateWebview = function updateWebview(webview, params) {
    return webchatDispatch({
      type: 'updateWebview',
      payload: {
        webview: webview,
        webviewParams: params
      }
    });
  };

  var updateSession = function updateSession(session) {
    return webchatDispatch({
      type: 'updateSession',
      payload: session
    });
  };

  var updateUser = function updateUser(user) {
    return webchatDispatch({
      type: 'updateUser',
      payload: user
    });
  };

  var updateLastRoutePath = function updateLastRoutePath(path) {
    return webchatDispatch({
      type: 'updateLastRoutePath',
      payload: path
    });
  };

  var updateHandoff = function updateHandoff(handoff) {
    return webchatDispatch({
      type: 'updateHandoff',
      payload: handoff
    });
  };

  var updateTheme = function updateTheme(theme) {
    return webchatDispatch({
      type: 'updateTheme',
      payload: theme
    });
  };

  var updateDevSettings = function updateDevSettings(settings) {
    return webchatDispatch({
      type: 'updateDevSettings',
      payload: settings
    });
  };

  var toggleWebchat = function toggleWebchat(toggle) {
    return webchatDispatch({
      type: 'toggleWebchat',
      payload: toggle
    });
  };

  var setError = function setError(error) {
    return webchatDispatch({
      type: 'setError',
      payload: error
    });
  };

  return {
    webchatState: webchatState,
    webchatDispatch: webchatDispatch,
    addMessage: addMessage,
    addMessageComponent: addMessageComponent,
    updateMessage: updateMessage,
    updateReplies: updateReplies,
    updateLatestInput: updateLatestInput,
    updateTyping: updateTyping,
    updateWebview: updateWebview,
    updateSession: updateSession,
    updateUser: updateUser,
    updateLastRoutePath: updateLastRoutePath,
    updateHandoff: updateHandoff,
    updateTheme: updateTheme,
    updateDevSettings: updateDevSettings,
    toggleWebchat: toggleWebchat,
    setError: setError
  };
}

function useTyping(_ref) {
  var webchatState = _ref.webchatState,
      updateTyping = _ref.updateTyping,
      updateMessage = _ref.updateMessage;
  (0, _react.useEffect)(function () {
    var delayTimeout, typingTimeout;
    var end = document.getElementById('messages-end');

    if (end) {
      end.scrollIntoView({
        behavior: 'smooth'
      });
      setTimeout(function () {
        return end.scrollIntoView({
          behavior: 'smooth'
        });
      }, 100);
    }

    try {
      var nextMsg = webchatState.messagesJSON.filter(function (m) {
        return !m.display;
      })[0];

      if (nextMsg.delay && nextMsg.typing) {
        delayTimeout = setTimeout(function () {
          return updateTyping(true);
        }, nextMsg.delay * 1000);
      } else if (nextMsg.typing) updateTyping(true);

      var totalDelay = nextMsg.delay + nextMsg.typing;
      if (totalDelay) typingTimeout = setTimeout(function () {
        updateMessage(_objectSpread({}, nextMsg, {
          display: true
        }));
        updateTyping(false);
      }, totalDelay * 1000);
    } catch (e) {}

    return function () {
      clearTimeout(delayTimeout);
      clearTimeout(typingTimeout);
    };
  }, [webchatState.messagesJSON]);
}

function usePrevious(value) {
  var ref = (0, _react.useRef)();
  (0, _react.useEffect)(function () {
    ref.current = value;
  });
  return ref.current;
}

function useComponentVisible(initialIsVisible) {
  var _useState = (0, _react.useState)(initialIsVisible),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      isComponentVisible = _useState2[0],
      setIsComponentVisible = _useState2[1];

  var ref = (0, _react.useRef)(null);

  var handleClickOutside = function handleClickOutside(event) {
    if (ref.current && !ref.current.contains(event.target)) {
      setIsComponentVisible(false);
    }
  };

  (0, _react.useEffect)(function () {
    document.addEventListener('click', handleClickOutside, true);
    return function () {
      document.removeEventListener('click', handleClickOutside, true);
    };
  });
  return {
    ref: ref,
    isComponentVisible: isComponentVisible,
    setIsComponentVisible: setIsComponentVisible
  };
}
//# sourceMappingURL=hooks.js.map