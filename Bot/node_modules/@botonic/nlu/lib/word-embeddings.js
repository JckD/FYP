(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "@babel/runtime/helpers/slicedToArray", "@babel/runtime/regenerator", "@babel/runtime/helpers/asyncToGenerator", "os", "colors", "path", "sqlite-async", "./constants", "./file-utils"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("@babel/runtime/helpers/slicedToArray"), require("@babel/runtime/regenerator"), require("@babel/runtime/helpers/asyncToGenerator"), require("os"), require("colors"), require("path"), require("sqlite-async"), require("./constants"), require("./file-utils"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.slicedToArray, global.regenerator, global.asyncToGenerator, global.os, global.colors, global.path, global.sqliteAsync, global.constants, global.fileUtils);
    global.wordEmbeddings = mod.exports;
  }
})(this, function (_exports, _slicedToArray2, _regenerator, _asyncToGenerator2, _os, _colors, _path, _sqliteAsync, _constants, _fileUtils) {
  "use strict";

  var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.getEmbeddingMatrix = getEmbeddingMatrix;
  _exports.generateEmbeddingMatrix = generateEmbeddingMatrix;
  _slicedToArray2 = _interopRequireDefault(_slicedToArray2);
  _regenerator = _interopRequireDefault(_regenerator);
  _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator2);
  _os = _interopRequireDefault(_os);
  _colors = _interopRequireDefault(_colors);
  _path = _interopRequireDefault(_path);
  _sqliteAsync = _interopRequireDefault(_sqliteAsync);

  function downloadWordEmbeddingsFile(_x, _x2) {
    return _downloadWordEmbeddingsFile.apply(this, arguments);
  }

  function _downloadWordEmbeddingsFile() {
    _downloadWordEmbeddingsFile = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(wordEmbeddingsPath, wordEmbeddingsFileName) {
      var downloadPath;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              console.log(_colors["default"].blue("Downloading '".concat(wordEmbeddingsFileName, "'...")));
              console.log("Please, wait until the download finishes.\n");
              downloadPath = _path["default"].join(wordEmbeddingsPath, wordEmbeddingsFileName);
              _context.next = 5;
              return (0, _fileUtils.downloadFileToDisk)({
                url: "".concat(_constants.WORD_EMBEDDDINGS_ENDPOINT, "/").concat(wordEmbeddingsFileName),
                downloadPath: downloadPath
              });

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _downloadWordEmbeddingsFile.apply(this, arguments);
  }

  function getEmbeddingMatrix(_x3) {
    return _getEmbeddingMatrix.apply(this, arguments);
  }

  function _getEmbeddingMatrix() {
    _getEmbeddingMatrix = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(_ref) {
      var vocabulary, vocabularyLength, params, wordEmbeddingsFileName, wordEmbeddingsPath, wordEmbeddingsFilePath, embeddingMatrix;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              vocabulary = _ref.vocabulary, vocabularyLength = _ref.vocabularyLength, params = _ref.params;
              wordEmbeddingsFileName = "".concat(params.EMBEDDING, "-").concat(params.EMBEDDING_DIM, "d-").concat(params.language, ".db");
              wordEmbeddingsPath = _path["default"].join(_os["default"].homedir(), _constants.GLOBAL_CONFIG_DIRNAME, _constants.WORD_EMBEDDINGS_DIRNAME);
              wordEmbeddingsFilePath = _path["default"].join(wordEmbeddingsPath, wordEmbeddingsFileName);

              if ((0, _fileUtils.pathExists)(wordEmbeddingsFilePath)) {
                _context2.next = 10;
                break;
              }

              console.log(_colors["default"].red("The file '".concat(wordEmbeddingsFileName, "' was not found in your machine.")));
              console.log('An automatic download will start in brief.');

              if (!(0, _fileUtils.pathExists)(wordEmbeddingsPath)) {
                (0, _fileUtils.createDir)(wordEmbeddingsPath);
              }

              _context2.next = 10;
              return downloadWordEmbeddingsFile(wordEmbeddingsPath, wordEmbeddingsFileName);

            case 10:
              _context2.next = 12;
              return generateEmbeddingMatrix({
                dim1: vocabularyLength,
                dim2: params.EMBEDDING_DIM,
                vocabulary: vocabulary,
                wordEmbeddingsFilePath: wordEmbeddingsFilePath
              });

            case 12:
              embeddingMatrix = _context2.sent;
              return _context2.abrupt("return", embeddingMatrix);

            case 14:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _getEmbeddingMatrix.apply(this, arguments);
  }

  function generateEmbeddingMatrix(_x4) {
    return _generateEmbeddingMatrix.apply(this, arguments);
  }

  function _generateEmbeddingMatrix() {
    _generateEmbeddingMatrix = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(_ref2) {
      var dim1, dim2, vocabulary, wordEmbeddingsFilePath, embeddingMatrix;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              dim1 = _ref2.dim1, dim2 = _ref2.dim2, vocabulary = _ref2.vocabulary, wordEmbeddingsFilePath = _ref2.wordEmbeddingsFilePath;
              embeddingMatrix = createEmbeddingMatrix(dim1, dim2);
              _context3.next = 4;
              return fillEmbeddingMatrix(vocabulary, embeddingMatrix, wordEmbeddingsFilePath);

            case 4:
              embeddingMatrix = _context3.sent;
              return _context3.abrupt("return", embeddingMatrix);

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _generateEmbeddingMatrix.apply(this, arguments);
  }

  function createEmbeddingMatrix(dim1, dim2) {
    var min = -1;
    var max = 1;
    var matrix = [];

    for (var i = 0; i < dim1; i++) {
      matrix[i] = new Array(dim2);

      for (var j = 0; j < dim2; j++) {
        matrix[i][j] = Math.random() * (max - min) + min;
      }
    }

    return matrix;
  }

  function fillEmbeddingMatrix(_x5, _x6, _x7) {
    return _fillEmbeddingMatrix.apply(this, arguments);
  }

  function _fillEmbeddingMatrix() {
    _fillEmbeddingMatrix = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee4(vocabulary, embeddingMatrix, wordEmbeddingsFilePath) {
      var out_of_embedding, db, _i, _Object$entries, _Object$entries$_i, word, index, res, d;

      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              out_of_embedding = 0;
              _context4.next = 3;
              return _sqliteAsync["default"].open(wordEmbeddingsFilePath);

            case 3:
              db = _context4.sent;
              _i = 0, _Object$entries = Object.entries(vocabulary);

            case 5:
              if (!(_i < _Object$entries.length)) {
                _context4.next = 26;
                break;
              }

              _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), word = _Object$entries$_i[0], index = _Object$entries$_i[1];

              if (!(index == 0)) {
                _context4.next = 9;
                break;
              }

              return _context4.abrupt("continue", 23);

            case 9:
              res = null;
              d = "'";

              if (word.includes("'")) {
                d = '"';
              }

              _context4.prev = 12;
              _context4.next = 15;
              return db.get("SELECT * FROM ".concat(_constants.DB.TABLE, " where ").concat(_constants.DB.COLUMN, "=").concat(d).concat(word).concat(d));

            case 15:
              res = _context4.sent;
              embeddingMatrix[index] = res.vector.split(' ');
              _context4.next = 23;
              break;

            case 19:
              _context4.prev = 19;
              _context4.t0 = _context4["catch"](12);
              console.log('Not found: [', word, '] Index: ', index);
              out_of_embedding++;

            case 23:
              _i++;
              _context4.next = 5;
              break;

            case 26:
              _context4.next = 28;
              return db.close();

            case 28:
              console.log('Words not found in embedding: ', out_of_embedding);
              return _context4.abrupt("return", embeddingMatrix);

            case 30:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[12, 19]]);
    }));
    return _fillEmbeddingMatrix.apply(this, arguments);
  }
});