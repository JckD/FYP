"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Webchat = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _reactTextareaAutosize = _interopRequireDefault(require("react-textarea-autosize"));

var _localStorage = require("@rehooks/local-storage");

var _v = _interopRequireDefault(require("uuid/v4"));

var _uaParserJs = _interopRequireDefault(require("ua-parser-js"));

var _grid = require("@rebass/grid");

var _core = require("@botonic/core");

var _contexts = require("../contexts");

var _text = require("../components/text");

var _typingIndicator = require("../components/typingIndicator");

var _handoff = require("../components/handoff");

var _hooks = require("./hooks");

var _header = require("./header");

var _persistentMenu = require("../components/persistentMenu");

var _messageList = require("./messageList");

var _replies = require("./replies");

var _webview = require("./webview");

var _utils = require("../utils");

var _botonic_react_logo100x = _interopRequireDefault(require("./botonic_react_logo100x100.png"));

var _emojiPickerReact = _interopRequireDefault(require("emoji-picker-react"));

var _menuButton = _interopRequireDefault(require("./menuButton.svg"));

var _emojiButton = _interopRequireDefault(require("./emojiButton.svg"));

var _button = require("../components/button");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var createUser = function createUser() {
  var parser = new _uaParserJs["default"]();
  var ua = parser.getResult();
  var name = "".concat(ua.os.name, " ").concat(ua.browser.name);
  if (ua.device && ua.device.type) name = "".concat(ua.device.type, " ").concat(name);
  return {
    id: (0, _v["default"])(),
    name: name
  };
};

var Webchat = (0, _react.forwardRef)(function (props, ref) {
  var _ref = props.webchatHooks || (0, _hooks.useWebchat)(),
      webchatState = _ref.webchatState,
      addMessage = _ref.addMessage,
      addMessageComponent = _ref.addMessageComponent,
      updateMessage = _ref.updateMessage,
      updateReplies = _ref.updateReplies,
      updateLatestInput = _ref.updateLatestInput,
      updateTyping = _ref.updateTyping,
      updateWebview = _ref.updateWebview,
      updateSession = _ref.updateSession,
      _updateUser = _ref.updateUser,
      updateLastRoutePath = _ref.updateLastRoutePath,
      updateHandoff = _ref.updateHandoff,
      updateTheme = _ref.updateTheme,
      updateDevSettings = _ref.updateDevSettings,
      _toggleWebchat = _ref.toggleWebchat,
      setError = _ref.setError,
      openWebviewT = _ref.openWebviewT,
      closeWebviewT = _ref.closeWebviewT;

  var initialSession = props.initialSession,
      initialDevSettings = props.initialDevSettings,
      onStateChange = props.onStateChange;

  var _useLocalStorage = (0, _localStorage.useLocalStorage)('botonicState'),
      _useLocalStorage2 = (0, _slicedToArray2["default"])(_useLocalStorage, 3),
      botonicState = _useLocalStorage2[0],
      saveState = _useLocalStorage2[1],
      deleteState = _useLocalStorage2[2];

  var _useState = (0, _react.useState)(false),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      menuIsOpened = _useState2[0],
      setMenuIsOpened = _useState2[1];

  var _useState3 = (0, _react.useState)(false),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      emojiIsOpened = _useState4[0],
      setEmojiIsOpened = _useState4[1]; // Load initial state from localStorage


  (0, _react.useEffect)(function () {
    var _ref2 = botonicState || {},
        user = _ref2.user,
        messages = _ref2.messages,
        session = _ref2.session,
        lastRoutePath = _ref2.lastRoutePath,
        devSettings = _ref2.devSettings;

    if (!user || Object.keys(user).length == 0) user = createUser();

    _updateUser(user);

    if (!devSettings || Object.keys(devSettings).length == 0 || devSettings.keepSessionOnReload) {
      if (messages) {
        messages.map(function (m) {
          addMessage(m);
          var newComponent = (0, _utils.msgToBotonic)(_objectSpread({}, m, {
            delay: 0,
            typing: 0
          }), props.theme.customMessageTypes);
          if (newComponent) addMessageComponent(newComponent);
        });
      }

      if (session) updateSession(session);else if (initialSession) updateSession(initialSession);
      if (lastRoutePath) updateLastRoutePath(lastRoutePath);
    } else updateSession(initialSession);

    if (devSettings) updateDevSettings(devSettings);else if (initialDevSettings) updateDevSettings(initialDevSettings);
    if (props.onInit) setTimeout(function () {
      return props.onInit();
    }, 100);
  }, []);
  (0, _react.useEffect)(function () {
    if (!webchatState.isWebchatOpen) return;
    setTimeout(function () {
      var end = document.getElementById('messages-end');

      if (end) {
        end.scrollIntoView();
      }
    });
  }, [webchatState.isWebchatOpen]);
  (0, _react.useEffect)(function () {
    if (onStateChange && typeof onStateChange === 'function') onStateChange(webchatState);
    saveState(JSON.stringify({
      user: webchatState.user,
      messages: webchatState.messagesJSON,
      session: webchatState.session,
      lastRoutePath: webchatState.lastRoutePath,
      devSettings: webchatState.devSettings
    }));
  }, [webchatState.user, webchatState.messagesJSON, webchatState.session, webchatState.lastRoutePath, webchatState.devSettings]);
  (0, _hooks.useTyping)({
    webchatState: webchatState,
    updateTyping: updateTyping,
    updateMessage: updateMessage
  });
  (0, _react.useEffect)(function () {
    updateTheme(_objectSpread({}, webchatState.theme, {}, props.theme));
  }, [props.theme]);

  var openWebview = function openWebview(webviewComponent, params) {
    return updateWebview(webviewComponent, params);
  };

  var emojiClick = function emojiClick(code) {
    var emoji = String.fromCodePoint("0x".concat(code));
    textArea.current.value += emoji;
    textArea.current.focus();
  };

  var closeWebview = function closeWebview(options) {
    updateWebview();
    textArea.current.focus();

    if (options && options.payload) {
      sendPayload(options.payload);
    } else if (options && options.path) {
      var params = '';
      if (options.params) params = (0, _core.params2queryString)(options.params);
      sendPayload("__PATH_PAYLOAD__".concat(options.path, "?").concat(params));
    }
  };

  var handleMenu = function handleMenu() {
    setEmojiIsOpened(false);
    menuIsOpened ? setMenuIsOpened(false) : setMenuIsOpened(true);
  };

  var handleEmoji = function handleEmoji() {
    emojiIsOpened ? setEmojiIsOpened(false) : setEmojiIsOpened(true);
  };

  var emojiPickerComponent = function emojiPickerComponent() {
    return _react["default"].createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        padding: 15
      }
    }, _react["default"].createElement("img", {
      style: {
        cursor: 'pointer'
      },
      src: (0, _utils.staticAsset)(_emojiButton["default"]),
      onClick: function onClick() {
        return handleEmoji();
      }
    }));
  };

  var persistentMenuComponent = function persistentMenuComponent() {
    return _react["default"].createElement(_persistentMenu.PersistentMenu, null, Object.values(props.persistentMenu).map(function (e, i) {
      return _react["default"].createElement(_button.Button, {
        onClick: closeMenu,
        url: e.url,
        webview: e.webview,
        payload: e.payload,
        key: i
      }, Object.values(e.label));
    }), _react["default"].createElement(_button.Button, {
      onClick: closeMenu
    }, "Cancel"));
  };

  var persistentMenuLogo = function persistentMenuLogo() {
    return _react["default"].createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        flex: 'none',
        cursor: 'pointer',
        padding: 18
      },
      onClick: function onClick() {
        return handleMenu();
      }
    }, _react["default"].createElement("img", {
      src: (0, _utils.staticAsset)(_menuButton["default"])
    }));
  };

  var checkBlockInput = function checkBlockInput(input) {
    if (!Array.isArray(props.blockInputs)) return;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = props.blockInputs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var rule = _step.value;

        if (rule.match.some(function (regex) {
          return regex.test(input.data);
        })) {
          addMessageComponent(_react["default"].createElement(_text.Text, {
            id: input.id,
            from: "user",
            style: {
              backgroundColor: '#585757',
              borderColor: '#585757'
            }
          }, rule.message));
          updateReplies(false);
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };

  var closeMenu = function closeMenu() {
    setMenuIsOpened(false);
  };

  var sendInput =
  /*#__PURE__*/
  function () {
    var _ref3 = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(input) {
      var inputMessage;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              inputMessage = null;

              if (!(!input || Object.keys(input).length == 0)) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              if (!input.id) input.id = (0, _v["default"])(); //if is a text we check if it is a RE

              if (!(input.type === 'text')) {
                _context.next = 8;
                break;
              }

              if (!checkBlockInput(input)) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return");

            case 7:
              inputMessage = _react["default"].createElement(_text.Text, {
                id: input.id,
                payload: input.payload,
                from: "user"
              }, input.data);

            case 8:
              if (inputMessage) {
                addMessageComponent(inputMessage);
              }

              props.onUserInput && props.onUserInput({
                user: webchatState.user,
                input: input,
                session: webchatState.session,
                lastRoutePath: webchatState.lastRoutePath
              });
              updateLatestInput(input);
              updateReplies(false);
              setMenuIsOpened(false);
              setEmojiIsOpened(false);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function sendInput(_x) {
      return _ref3.apply(this, arguments);
    };
  }();
  /* This is the public API this component exposes to its parents
  https://stackoverflow.com/questions/37949981/call-child-method-from-parent
  */


  (0, _react.useImperativeHandle)(ref, function () {
    return {
      addBotResponse: function addBotResponse(_ref4) {
        var response = _ref4.response,
            session = _ref4.session,
            lastRoutePath = _ref4.lastRoutePath;
        updateTyping(false);
        if (Array.isArray(response)) response.map(function (r) {
          return addMessageComponent(r);
        });else if (response) addMessageComponent(response);

        if (session) {
          updateSession(session);
          var action = session._botonic_action || '';
          var handoff = action.startsWith('create_case');
          if (handoff && (0, _utils.isDev)()) addMessageComponent(_react["default"].createElement(_handoff.Handoff, null));
          updateHandoff(handoff);
        }

        if (lastRoutePath) updateLastRoutePath(lastRoutePath);
      },
      setTyping: function setTyping(typing) {
        return updateTyping(typing);
      },
      addUserMessage: function addUserMessage(message) {
        return sendInput(message);
      },
      updateUser: function updateUser(user) {
        updateSession(_objectSpread({}, webchatState.session, {
          user: _objectSpread({}, webchatState.session.user, {}, user)
        }));

        _updateUser(_objectSpread({}, webchatState.user, {}, user));
      },
      openWebchat: function openWebchat() {
        return _toggleWebchat(true);
      },
      closeWebchat: function closeWebchat() {
        return _toggleWebchat(false);
      },
      toggleWebchat: function toggleWebchat() {
        return _toggleWebchat(!webchatState.isWebchatOpen);
      },
      openWebviewApi: function openWebviewApi(component) {
        return openWebviewT(component);
      },
      setError: setError
    };
  });

  var resolveCase = function resolveCase() {
    updateHandoff(false);
    updateSession(_objectSpread({}, webchatState.session, {
      _botonic_action: null
    }));
  };

  var prevSession = (0, _hooks.usePrevious)(webchatState.session);
  (0, _react.useEffect)(function () {
    // Resume conversation after handoff
    if (prevSession && prevSession._botonic_action && !webchatState.session._botonic_action) {
      var action = prevSession._botonic_action.split(':');

      sendPayload(action[action.length - 1]);
    }
  }, [webchatState.session._botonic_action]);

  var sendText =
  /*#__PURE__*/
  function () {
    var _ref5 = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(text, payload) {
      var input;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (text) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              input = {
                type: 'text',
                data: text,
                payload: payload
              };
              _context2.next = 5;
              return sendInput(input);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function sendText(_x2, _x3) {
      return _ref5.apply(this, arguments);
    };
  }();

  var sendPayload =
  /*#__PURE__*/
  function () {
    var _ref6 = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(payload) {
      var input;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (payload) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              input = {
                type: 'postback',
                payload: payload
              };
              _context3.next = 5;
              return sendInput(input);

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function sendPayload(_x4) {
      return _ref6.apply(this, arguments);
    };
  }();

  var _onKeyDown = function onKeyDown(event) {
    if (event.keyCode == 13 && event.shiftKey == false) {
      event.preventDefault();
      sendText(textArea.current.value);
      textArea.current.value = '';
    }
  };

  var webviewRequestContext = {
    getString: function getString(stringId) {
      return props.getString(stringId, webchatState.session);
    },
    setLocale: function setLocale(locale) {
      return props.getString(locale, webchatState.session);
    },
    session: webchatState.session || {},
    params: webchatState.webviewParams || {},
    closeWebview: closeWebview
  };
  (0, _react.useEffect)(function () {
    if (webchatState.isWebchatOpen && props.onOpen) props.onOpen();
    if (!webchatState.isWebchatOpen && props.onClose) props.onClose();
  }, [webchatState.isWebchatOpen]);
  var textArea = (0, _react.useRef)();
  var CustomTriggerButton = webchatState.theme.customTrigger;
  var triggerImage = _botonic_react_logo100x["default"];
  if (props.theme && 'triggerButtonImage' in props.theme) triggerImage = props.theme.triggerButtonImage;
  if (webchatState.theme && 'triggerButtonImage' in webchatState.theme) triggerImage = webchatState.theme.triggerButtonImage;
  var triggerButton = CustomTriggerButton ? _react["default"].createElement(CustomTriggerButton, null) : _react["default"].createElement("div", {
    style: _objectSpread({
      cursor: 'pointer',
      position: 'fixed',
      background: 'white',
      borderRadius: '50%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      overflow: 'hidden',
      width: 65,
      height: 65,
      bottom: 20,
      paddding: 8,
      right: 10
    }, webchatState.theme.triggerButtonStyle)
  }, triggerImage && _react["default"].createElement("img", {
    style: {
      maxWidth: '100%',
      maxHeight: '100%'
    },
    src: (0, _utils.staticAsset)(triggerImage)
  }));

  var webchatHeader = function webchatHeader() {
    return _react["default"].createElement(_header.WebchatHeader, {
      style: {
        borderRadius: '8px 8px 0 0',
        boxShadow: 'rgba(176, 196, 222, 0.5) 0px 2px 5px',
        height: 36,
        flex: 'none'
      },
      onCloseClick: function onCloseClick() {
        _toggleWebchat(false);
      }
    });
  };

  var webchatMessageList = function webchatMessageList() {
    return _react["default"].createElement(_messageList.WebchatMessageList, {
      style: {
        flex: 1
      },
      messages: webchatState.messagesComponents
    }, webchatState.typing && _react["default"].createElement(_typingIndicator.TypingIndicator, null), _react["default"].createElement("div", {
      id: "messages-end"
    }));
  };

  var webchatReplies = function webchatReplies() {
    return _react["default"].createElement(_replies.WebchatReplies, {
      replies: webchatState.replies,
      align: webchatState.theme.alignReplies,
      wrap: webchatState.theme.wrapReplies
    });
  };

  var emoji = function emoji() {
    return _react["default"].createElement("div", {
      style: {
        width: webchatState.theme.width || '100%',
        maxWidth: 400,
        display: 'flex',
        justifyContent: 'flex-end',
        position: 'absolute',
        right: 0,
        top: -332
      }
    }, _react["default"].createElement(_emojiPickerReact["default"], {
      onEmojiClick: emojiClick
    }));
  };

  var inputUserArea = function inputUserArea() {
    return _react["default"].createElement("div", {
      style: {
        minHeight: 52,
        display: 'flex',
        position: 'relative',
        borderTop: '1px solid rgba(0, 0, 0, 0.4)'
      }
    }, emojiIsOpened && emoji(), props.persistentMenu && persistentMenuLogo(), _react["default"].createElement("div", {
      style: {
        display: 'flex',
        flex: '1 1 auto',
        alignItems: 'center'
      }
    }, _react["default"].createElement(_reactTextareaAutosize["default"], {
      name: "text",
      maxRows: 4,
      wrap: "soft",
      maxLength: "1000",
      placeholder: webchatState.theme.textPlaceholder,
      autoFocus: location.hostname === 'localhost',
      inputRef: textArea,
      onKeyDown: function onKeyDown(e) {
        return _onKeyDown(e);
      },
      style: {
        display: 'flex',
        fontSize: 14,
        width: '100%',
        border: 'none',
        resize: 'none',
        overflow: 'auto',
        outline: 'none',
        flex: '1 1 auto',
        padding: 10,
        paddingLeft: props.persistentMenu ? 0 : 10
      }
    })), props.emojiPicker && emojiPickerComponent());
  };

  var webchatWebview = function webchatWebview() {
    return _react["default"].createElement(_contexts.RequestContext.Provider, {
      value: webviewRequestContext
    }, _react["default"].createElement(_webview.WebviewContainer, {
      style: _objectSpread({}, props.theme.webviewStyle),
      webview: webchatState.webview
    }));
  };

  return _react["default"].createElement(_contexts.WebchatContext.Provider, {
    value: {
      sendText: sendText,
      sendPayload: sendPayload,
      openWebview: openWebview,
      resolveCase: resolveCase,
      webchatState: webchatState,
      addMessage: addMessage,
      toggleWebchat: _toggleWebchat,
      updateMessage: updateMessage,
      updateReplies: updateReplies,
      updateLatestInput: updateLatestInput
    }
  }, !webchatState.isWebchatOpen && _react["default"].createElement("div", {
    onClick: function onClick(event) {
      _toggleWebchat(true);

      event.preventDefault();
    }
  }, triggerButton), webchatState.isWebchatOpen && _react["default"].createElement("div", {
    style: _objectSpread({
      position: 'fixed',
      right: 20,
      bottom: 20,
      width: webchatState.width,
      height: webchatState.height,
      margin: 'auto',
      backgroundColor: 'white',
      borderRadius: '10px',
      boxShadow: '0 0 12px rgba(0,0,0,.15)',
      display: 'flex',
      flexDirection: 'column'
    }, webchatState.theme.style)
  }, webchatHeader(), webchatState.error.message ? _react["default"].createElement("div", {
    style: {
      flex: '1 1 auto',
      display: 'flex',
      backgroundColor: 'white',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: 'Arial, Helvetica, sans-serif'
    }
  }, "Error: ", webchatState.error.message) : _react["default"].createElement(_react["default"].Fragment, null, webchatMessageList(), webchatState.replies && Object.keys(webchatState.replies).length > 0 && webchatReplies(), menuIsOpened && persistentMenuComponent(), !webchatState.handoff && inputUserArea(), webchatState.webview && webchatWebview())));
});
exports.Webchat = Webchat;
//# sourceMappingURL=webchat.js.map