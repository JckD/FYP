"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Router = void 0;

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _objectDestructuringEmpty2 = _interopRequireDefault(require("@babel/runtime/helpers/objectDestructuringEmpty"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var url = _interopRequireWildcard(require("url"));

var _utils = require("./utils");

var Router =
/*#__PURE__*/
function () {
  function Router(routes) {
    (0, _classCallCheck2["default"])(this, Router);
    this.routes = routes;
  }

  (0, _createClass2["default"])(Router, [{
    key: "processInput",
    value: function processInput(input) {
      var session = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var lastRoutePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var routeParams = {};
      var path_params;

      try {
        path_params = input.payload.split('__PATH_PAYLOAD__')[1].split('?');
        if (path_params.length > 0) input.path = path_params[0];
      } catch (e) {}

      var brokenFlow = false;
      var lastRoute = this.getRouteByPath(lastRoutePath, this.routes);
      if (lastRoute && lastRoute.childRoutes) //get route depending of current ChildRoute
        routeParams = this.getRoute(input, lastRoute.childRoutes);

      if (!routeParams || !Object.keys(routeParams).length) {
        /*
            we couldn't find a route in the state of the lastRoute, so let's find in
            the general conf.route
          */
        brokenFlow = Boolean(lastRoutePath);
        routeParams = this.getRoute(input, this.routes, session);
      }

      try {
        if (path_params.length > 1) {
          var searchParams = '';
          if ((0, _utils.isBrowser)()) searchParams = new URLSearchParams(path_params[1]);
          if ((0, _utils.isNode)()) searchParams = new url.URLSearchParams(path_params[1]);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = searchParams[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
                  key = _step$value[0],
                  value = _step$value[1];

              routeParams.params ? routeParams.params[key] = value : routeParams.params = (0, _defineProperty2["default"])({}, key, value);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      } catch (e) {}

      if (routeParams && Object.keys(routeParams).length) {
        //get in childRoute if one has path ''
        var defaultAction;

        if (!routeParams.route.path && routeParams.route && routeParams.route.childRoutes && routeParams.route.childRoutes.length) {
          defaultAction = this.getRoute({
            path: ''
          }, routeParams.route.childRoutes);
        }

        if ('action' in routeParams.route) {
          if (brokenFlow && routeParams.route.ignoreRetry != true && lastRoute && session.__retries < lastRoute.retry && routeParams.route.path != lastRoute.action) {
            session.__retries = session.__retries ? session.__retries + 1 : 1; // The flow was broken, but we want to recover it

            return {
              action: routeParams.route.action,
              params: routeParams.params,
              retryAction: lastRoute ? lastRoute.action : null,
              defaultAction: defaultAction ? defaultAction.route.action : null,
              lastRoutePath: lastRoutePath
            };
          } else {
            session.__retries = 0;
            if (lastRoutePath && !brokenFlow) lastRoutePath = "".concat(lastRoutePath, "/").concat(routeParams.route.path);else lastRoutePath = routeParams.route.path;
            return {
              action: routeParams.route.action,
              params: routeParams.params,
              retryAction: null,
              defaultAction: defaultAction ? defaultAction.route.action : null,
              lastRoutePath: lastRoutePath
            };
          }
        } else if (defaultAction) {
          return {
            action: defaultAction.route.action,
            params: defaultAction.params,
            lastRoutePath: lastRoutePath
          };
        } else if ('redirect' in routeParams.route) {
          lastRoutePath = routeParams.route.redirect;
          var redirectRoute = this.getRouteByPath(lastRoutePath, this.routes);

          if (redirectRoute) {
            return {
              action: redirectRoute.action,
              params: redirectRoute.params,
              lastRoutePath: lastRoutePath
            };
          }
        }
      }

      var notFound = this.getRouteByPath('404', this.routes);

      if (lastRoute && session.__retries < lastRoute.retry) {
        session.__retries = session.__retries ? session.__retries + 1 : 1;
        return {
          action: notFound.action,
          params: {},
          retryAction: lastRoute.action,
          lastRoutePath: lastRoutePath
        };
      } else {
        this.lastRoutePath = null;
        session.__retries = 0;
        return {
          action: notFound.action,
          params: {},
          retryAction: null,
          lastRoutePath: lastRoutePath
        };
      }
    }
  }, {
    key: "getRoute",
    value: function getRoute(input, routes, session) {
      var _this = this;

      /* Find the route that matches the given input, if it match with some of the entries,
        return the whole Route of the entry with optional params captured if matcher was a regex */
      var params = {};
      var route = routes.find(function (r) {
        return Object.entries(r).filter(function (_ref) {
          var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
              key = _ref2[0];

          (0, _objectDestructuringEmpty2["default"])(_ref2[1]);
          return key != 'action' && key != 'childRoutes';
        }).some(function (_ref3) {
          var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
              key = _ref4[0],
              value = _ref4[1];

          var match = _this.matchRoute(key, value, input, session);

          try {
            params = match.groups;
          } catch (e) {}

          return Boolean(match);
        });
      });

      if (route) {
        return {
          route: route,
          params: params
        };
      }

      return null;
    }
  }, {
    key: "getRouteByPath",
    value: function getRouteByPath(path, routeList) {
      if (!path) return null;
      var route = null;
      routeList = routeList || this.routes;

      var _path$split = path.split('/'),
          _path$split2 = (0, _toArray2["default"])(_path$split),
          currentPath = _path$split2[0],
          childPath = _path$split2.slice(1);

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = routeList[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var r = _step2.value;

          //iterate over all routeList
          if (r.path == currentPath) {
            route = r;

            if (r.childRoutes && r.childRoutes.length && childPath.length > 0) {
              //evaluate childroute over next actions
              route = this.getRouteByPath(childPath.join('/'), r.childRoutes);
              if (route) return route;
            } else if (childPath.length == 0) return route; //last action and found route

          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return null;
    }
  }, {
    key: "matchRoute",
    value: function matchRoute(prop, matcher, input, session) {
      /*
          prop: ('text' | 'payload' | 'intent' | 'type' | 'input' | 'session' |...)
          matcher: (string: exact match | regex: regular expression match | function: return true)
          input: user input object, ex: {type: 'text', data: 'Hi'}
        */
      var value = '';
      if (Object.keys(input).indexOf(prop) > -1) value = input[prop];

      if (prop == 'text') {
        if (input.type == 'text') value = input.data;
      } else if (prop == 'input') value = input;else if (prop == 'session') value = session;

      if (typeof matcher === 'string') return value == matcher;
      if (matcher instanceof RegExp) return matcher.exec(value);
      if (typeof matcher === 'function') return matcher(value);
      return false;
    }
  }]);
  return Router;
}();

exports.Router = Router;
//# sourceMappingURL=router.js.map